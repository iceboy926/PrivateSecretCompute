//
//  RingSignProtocols.c
//  testSM2
//
//  Created by zuoyongyong on 2019/11/19.
//  Copyright © 2019年 zuoyongyong. All rights reserved.
//

#include "RingSignProtocols.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include "sm3.h"
#include "sm4.h"
#include "kdf.h"
#include "jvcrypto.h"

#define RING_COUNT  10
#define TEST

int ringGenkeyPair(unsigned char *prikey, unsigned int *prikeylen, unsigned char *pubkey, unsigned int *pubkeylen)
{
    //generate signer keypair (ai, Ai)  user include (0,1,2, ..., n-1)
    // generate other n-1 pubkey A0,A1,A2, ..Ai-1,..Ai+1..,An-1
    
    unsigned char*    pTemp_k = NULL;
    BIGNUM         *N;
    BIGNUM        *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz;
    unsigned char szpubkey[100] = {0};
    
    
    N = BN_new();
    kt = BN_new();
    x = BN_new();
    y = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    pTemp_k = (unsigned char*)malloc(256);
    
    if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    /* start to generate d , d is random ,d is in [1, n-2] */
    /* d must be generated by SM3 random generator */
generate_d:
    
    if(rng(g_uNumbits, pTemp_k))
    {
        //PRINT_ERROR("rng return error\n");
        return 1;
    }
    BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
    BN_nnmod(kt, kt, N, ctx);
    
    if( BN_is_zero(kt) )
    {
        goto generate_d;
    }
    
    
    //bn_bn2bin(kt, g_uNumbits/8, prikey);
    if(prikey != NULL)
    {
        BN_bn2bin(kt, prikey);
        *prikeylen = g_uNumbits/8;
    }
    
    
    //compute pubkey
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pz);
    EC_SM2_POINT_get_point(Pz, x, y, kt);
    
    BN_hex2bn(&kt, "04");
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, x);
    
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, y);
    
    //bn_bn2bin(kt, 1 + 2 * g_uNumbits/8, pubkey);
    BN_bn2bin(kt, szpubkey);
    if(pubkey != NULL)
    {
        *pubkeylen = 2 * g_uNumbits/8;
        memcpy(pubkey, szpubkey+1, *pubkeylen);
    }
    

    //free resource
    BN_free(N);
    BN_free(kt);
    BN_CTX_free(ctx);
    free(pTemp_k);
    
    return 0;
}

int ringSignGen(unsigned char *plain, unsigned int plainlen, unsigned int signer, unsigned char *prikey, unsigned int prikeylen, unsigned char (*allPubkey)[64], unsigned int pubkey_count, unsigned char *sign, unsigned int *signlen)
{
    //1、signer generate  n-1 random,  s0, s1, s2, ...si-1, si+1, ...sn-1  basepoint G  , si is been computed  in step 4
    unsigned char *pTemp = NULL;
    BIGNUM        *N;
    BIGNUM        *stArray[RING_COUNT];
    BIGNUM        *ctArray[RING_COUNT];
    BIGNUM        *x;
    BIGNUM        *y;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz,*R;
    BIGNUM        *kt,*at;
    BIGNUM        *one;
    unsigned char szpubkey[64] = {0};
    unsigned char szsign[32] = {0};
    unsigned char szprint[128] = {0};
    
    N = BN_new();
    x = BN_new();
    y = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    R = EC_SM2_POINT_new();
    one = BN_new();
    pTemp = (unsigned char*)malloc(256);
    
    if (ctx == NULL || pTemp == NULL )
    {
        return 1;
    }
    
    if(signer >= RING_COUNT)
    {
        return 1;
    }
    
    EC_SM2_GROUP_get_order(group, N);
    
    for(int i = 0; i < RING_COUNT; i++)
    {
        stArray[i] = BN_new();
        ctArray[i] = BN_new();
        
    generate_d:
        
        memset(pTemp, 0, 256);
        if(rng(g_uNumbits, pTemp))
        {
            //PRINT_ERROR("rng return error\n");
            return 1;
        }
        if(i == signer)
        {
            kt = BN_new();
            BN_bin2bn(pTemp, g_uNumbits/8, kt);
            BN_nnmod(kt, kt, N, ctx);
            
            if( BN_is_zero(kt) )
            {
                goto generate_d;
            }
        }
        else
        {
            BN_bin2bn(pTemp, g_uNumbits/8, stArray[i]);
            BN_nnmod(stArray[i], stArray[i], N, ctx);
            
            if( BN_is_zero(stArray[i]) )
            {
                goto generate_d;
            }
        }
    }
    
    //2 signer generate  a random k, compute kG = P  , assume P = si*G + ci*Ai; then c(i+1) = Hash(m||P)
    
    int i = (signer+1)%RING_COUNT;
    
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pt);
    EC_SM2_POINT_get_point(Pt, x, y, one);
    
    BN_lshift(x, x, g_uNumbits);
    BN_add(x, x, y);
    BN_bn2bin(x, szpubkey);
    
    unsigned char szData[1024] = {0};
    unsigned char szHash[32] = {0};
    memcpy(szData, plain, plainlen);
    memcpy(szData+plainlen, szpubkey, 64);
    SM3(szData, plainlen + 64, szHash);
    
    BN_bin2bn(szHash, sizeof(szHash), ctArray[i]);
    sprintf(szprint, "c%d is ",i);
    print_hex(szprint, szHash, sizeof(szHash));
    
    
    //3、according to formual c(i) = Hash(m|| (si-1*G + ci-1*Ai-1)) i = {0,1,2, ..n-1}     c0 = Hash(m||(sn-1*G + cn-1*An-1))  m is plaintext
    // as we know: ci+1 = Hash(m|| (si*G + ci*Ai)) = Hash(m|| P); then continue calculate  {ci+1,ci+2, .., cn-1,c0, c1, c2,...ci}
    // then perform an Ring-Sign

    while (i != signer) {
        
        memset(szData, 0, sizeof(szData));
        memset(szHash, 0, sizeof(szHash));
        memset(szpubkey, 0, sizeof(szpubkey));
        
        // pubkey
        BN_bin2bn(*(allPubkey+i), g_uNumbits/8, x);
        BN_bin2bn(*(allPubkey+i)+32, g_uNumbits/8, y);
        BN_hex2bn(&one, "1");
        EC_SM2_POINT_set_point(Pt, x, y, one);
        
        //R = si*G + ci*Ai;
        EC_SM2_POINT_mul(group, Pz, stArray[i], G);
        EC_SM2_POINT_mul(group, Pt, ctArray[i],Pt);
        EC_SM2_POINT_add(group, R, Pt, Pz);
        EC_SM2_POINT_affine2gem(group, R, R);
        EC_SM2_POINT_get_point(R, x, y, one);
        BN_lshift(x, x, g_uNumbits);
        BN_add(x, x, y);
        BN_bn2bin(x, szpubkey);
        
        // ci+1 = Hash(m||R)
        memcpy(szData, plain, plainlen);
        memcpy(szData + plainlen, szpubkey, 64);
        SM3(szData, plainlen+64, szHash);
        BN_bin2bn(szHash, sizeof(szHash), ctArray[(i+1)%RING_COUNT]);
    
        i++;
        i = i%RING_COUNT;
        
        printf("i = %d signer = %d \n", i, signer);
        sprintf(szprint, "c%d is ", i);
        print_hex((uint8_t *)szprint, szHash, 32);
    }
    
    //4、 according to ci, signer compute si = k - ci*ai
    at = BN_new();
    BN_bin2bn(prikey, prikeylen, at);
    
    BN_mul(at, ctArray[signer], at, ctx);
    BN_nnmod(at, at, N, ctx);
    BN_sub(stArray[signer], kt, at);
    BN_nnmod(stArray[signer], stArray[signer], N, ctx);
    
    
    //5、 perform an signature is {c0, s0, s1,...sn-1}
    //output sign
    BN_bn2bin(ctArray[0], szsign);
    memcpy(sign, szsign, sizeof(szsign));
    *signlen = 32;

    for(i = 0; i < RING_COUNT; i++)
    {
        memset(szsign, 0, sizeof(szsign));
        BN_bn2bin(stArray[i], szsign);
        memcpy(sign+(*signlen), szsign, 32);
        *signlen += 32;
        //free resource
        BN_free(ctArray[i]);
        BN_free(stArray[i]);
    }
    
    //free resouce
    
    
    BN_free(N);
    BN_free(kt);
    BN_free(x);
    BN_free(y);
    BN_free(one);
    BN_free(at);
    EC_SM2_POINT_free(Pt);
    EC_SM2_POINT_free(Pz);
    EC_SM2_POINT_free(R);
    BN_CTX_free(ctx);
    free(pTemp);
    
    
    
    return 0;
    
}

int ringVerifySign(unsigned char* plain, unsigned int plainlen, unsigned char (*allPubkey)[64], unsigned int pubkey_count, unsigned char *sign, unsigned int signlen)
{
    
    if(sign == NULL || plain == NULL)
    {
        return 0;
    }
    
    BIGNUM *c,*temp;
    BIGNUM *si;
    BIGNUM        *N;
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *one;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz,*R;
    EC_SM2_POINT *Pi;
    int i = 0;
    unsigned char szpubkey[64] = {0};
    unsigned char szData[1024] = {0};
    unsigned char szHash[32] = {0};
    unsigned char szprint[128] = {0};
    
    N = BN_new();
    x = BN_new();
    y = BN_new();
    c = BN_new();
    temp = BN_new();
    si = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    R = EC_SM2_POINT_new();
    Pi = EC_SM2_POINT_new();
    one = BN_new();
    
    
    //1、 convert sign to {c0, s0, s1, ..., sn-1}    convert all pubkey to {A0, A1,....,An-2, An-1}
    
    EC_SM2_GROUP_get_order(group, N);
    
    BN_bin2bn(sign, 32, c);
    BN_bin2bn(sign, 32, temp);
    
    //2、 according to formual ci = Hash(m||si-1*G + ci-1*Ai-1) compute c1,c2, ...cn-1 then wo get c0'
    // c1 = Hash(m||s0*G + c0*A0)
    // c2 = Hash(m||s1*G + c1*A1)
    // .....
    // .....
    // c0' = Hash(m||sn-1*G + cn-1*An-1)
    //
    while (i < RING_COUNT) {
        BN_bin2bn(sign+(i+1)*32, 32, si);
        
        BN_bin2bn(*(allPubkey+i), g_uNumbits/8, x);
        BN_bin2bn(*(allPubkey+i)+32, g_uNumbits/8, y);
        BN_hex2bn(&one, "1");
        EC_SM2_POINT_set_point(Pi, x, y, one);
        
        //ci = Hash(m||si-1*G + ci-1*Ai-1)
        EC_SM2_POINT_mul(group, Pz, si, G);
        EC_SM2_POINT_mul(group, Pt, temp, Pi);
        EC_SM2_POINT_add(group, R, Pz, Pt);
        
        EC_SM2_POINT_affine2gem(group, R, R);
        EC_SM2_POINT_get_point(R, x, y, one);
        
        BN_lshift(x, x, g_uNumbits);
        BN_add(x, x, y);
        BN_bn2bin(x, szpubkey);

        memcpy(szData,plain, plainlen);
        memcpy(szData+plainlen, szpubkey, 64);
        
        SM3(szData, plainlen+64, szHash);
        
        sprintf(szprint, "c%d is ", (i+1)%RING_COUNT);
        print_hex(szprint, szHash, 32);
        //
        BN_bin2bn(szHash, 32, temp);
        
        i++;
    }
    
    //3、 compare c0's is equal to c0 to complate verify signature
    // check c0' c0
    
    if(BN_cmp(temp, c) == 0)
    {
        printf("c0 == c0',verify success \n");
        
        BN_free(N);
        BN_free(c);
        BN_free(x);
        BN_free(y);
        BN_free(one);
        BN_free(si);
        EC_SM2_POINT_free(Pt);
        EC_SM2_POINT_free(Pz);
        EC_SM2_POINT_free(R);
        EC_SM2_POINT_free(Pi);
        BN_CTX_free(ctx);
        return 0;
    }
    else
    {
        printf("c0 != c0', verify failed ..\n");
        BN_free(N);
        BN_free(c);
        BN_free(x);
        BN_free(y);
        BN_free(one);
        BN_free(si);
        EC_SM2_POINT_free(Pt);
        EC_SM2_POINT_free(Pz);
        EC_SM2_POINT_free(R);
        EC_SM2_POINT_free(Pi);
        BN_CTX_free(ctx);
        return 1;
    }
}



void test_Ring_Sign()
{
    //
    //generate signer keypair (ai, Ai)  user include (0,1,2, ..., n-1)
    // generate other n-1 pubkey A0,A1,A2, ..Ai-1,..Ai+1..,An-1
    unsigned char *plainText = "the message to be sign";
    unsigned int plainlen = 0;
    
    unsigned char prikey[RING_COUNT][32] = {0};
    unsigned char pubkey[RING_COUNT][64] = {0};
    unsigned int prikeylen = 32;
    unsigned int pubkeylen = 64;
    
    unsigned char signData[(RING_COUNT+1)*32] = {0};
    unsigned int signDatalen = sizeof(signData);
    int ret = 0;
    
    
    sm2_init();
    
    for(int i = 0; i < RING_COUNT; i++)
    {
        ret = ringGenkeyPair(prikey[i], &prikeylen, pubkey[i], &pubkeylen);
        if(ret != 0)
        {
            printf("ringGenkeyPair failed ...\n");
            return ;
        }
    }
    
    //the one signer choose own's privatekey public key
    int signer = 1;
    
    unsigned char signer_prikey[32] = {0};
    
    //the signer get other pubkeey
    memcpy(signer_prikey, prikey[signer], prikeylen);

    plainlen = strlen(plainText);
    
    ret = ringSignGen(plainText, plainlen, signer, signer_prikey, prikeylen, pubkey, RING_COUNT, signData, &signDatalen);
    if(ret != 0)
    {
        printf(" sign ringsign data failed ...\n");
        return ;
    }
    
    //print_hex("sign is ", signData, signDatalen);
    
    printf("ringSign success ..\n");
    
    ret = ringVerifySign(plainText, plainlen, pubkey, RING_COUNT, signData, signDatalen);
    if(ret != 0)
    {
        printf(" verify Ring sign data failed ..\n");
        return ;
    }
    
    printf("ring sign and verify data success \n");
    
}
