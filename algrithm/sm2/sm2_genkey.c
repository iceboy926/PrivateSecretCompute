/* sm2_genkey.c */
#include <stdio.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include <stdlib.h>
#include <string.h>

/*
 * function:            generate ecc private key, which is d in SM2 standard.
 * arguments:           prikey, the private key buffer point.
 *			prikey_len, the lenth of private key buffer, must bigger than SM2_PRIKEY_LEN.
 * return value:        0 for success.  non-zero for error code.
 */
int sm2_gen_prikey(unsigned char *prikey, unsigned int *prikey_len)
{
	unsigned char*	pTemp_k = NULL;
	BIGNUM 		*N;
	BIGNUM		*kt;
	BN_CTX 		*ctx;

	if( prikey == NULL  || *prikey_len < g_uNumbits/8 )
	{
		return 1;
	}
	
	N = BN_new();
	kt = BN_new();
	ctx= BN_CTX_new();
	pTemp_k = (unsigned char*)malloc(RANDOM_LEN);
	
	if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
	{
		return 1;
	}
	EC_SM2_GROUP_get_order(group, N);

	/* start to generate d , d is random ,d is in [1, n-2] */
	/* d must be generated by SM3 random generator */
generate_d:
	
	if(rng(g_uNumbits, pTemp_k))
	{
		//PRINT_ERROR("rng return error\n");
		return 1;
	}
	BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
	BN_nnmod(kt, kt, N, ctx);			
	
	if( BN_is_zero(kt) )
	{
#ifdef TEST
		PRINT_INFO("kt is zeor\n");
#endif
		goto generate_d;
	}
	//bn_bn2bin(kt, g_uNumbits/8, prikey);
	BN_bn2bin(kt, prikey);
	*prikey_len = g_uNumbits/8;
	
	BN_free(N);
	BN_free(kt);
	BN_CTX_free(ctx);
	free(pTemp_k);

	return 0;
}


/*
 * function:            generate private key and pubkey key of ecc.
 * arguments:           prikey, the private key buffer point.
 *			prikey_len, the lenth of private key buffer, must bigger than SM2_PRIKEY_LEN.
 * 	                pubkey, the public key buffer point.
 *			pubkey_len, the lenth of public key buffer, must bigger than SM2_PUBKEY_LEN.
 * return value:        0 for success.  non-zero for error code.
 */
int sm2_genkey(unsigned char *prikey, unsigned int *prikey_len, unsigned char *pubkey, unsigned int *pubkey_len)
{
	int ret;
	ret = sm2_gen_prikey(prikey, prikey_len);
	if( ret == 1 )
		return 1;

	ret = sm2_point_from_privatekey(prikey, *prikey_len, pubkey, pubkey_len);
	if( ret == 1 )
		return 1;

	return 0;
}


/*
 * function:            calculate ecc public key from ecc private key. P=(xp, yp)=[d]G.
 * arguments:           prikey, the private key buffer point.
 *			prikey_len, the lenth of private key buffer, must bigger than SM2_PRIKEY_LEN.
 * 	                pubkey, the public key buffer point.
 *			pubkey_len, the lenth of public key buffer, must bigger than SM2_PUBKEY_LEN.
 * return value:        0 for success.  non-zero for error code.
 */
int sm2_point_from_privatekey(const unsigned char *prikey, const unsigned int prikey_len, unsigned char *pubkey, unsigned int *pubkey_len)
{
	BIGNUM 		*N;
	BIGNUM		*kt;
	BIGNUM		*x;
	BIGNUM		*y;
	EC_SM2_POINT	*Pt;
	EC_SM2_POINT	*Pz;
	BN_CTX 		*ctx;

	if( prikey == NULL || pubkey == NULL || pubkey_len == NULL )
	{
		return 1;
	}

	if( (prikey_len != g_uNumbits/8) || (*pubkey_len < 1 + 2 * g_uNumbits/8) )
	{
		return 1;
	}

	ctx= BN_CTX_new();
	N = BN_new();
	kt = BN_new();
	x = BN_new();
	y = BN_new();
	Pt = EC_SM2_POINT_new();
	Pz = EC_SM2_POINT_new();

	if ( N == NULL || kt == NULL || x == NULL || y == NULL ||
		 Pt == NULL || Pz == NULL || ctx == NULL )
	{
		return 1;
	}

	EC_SM2_GROUP_get_order(group, N);

	/* step 1 */
	BN_bin2bn(prikey, g_uNumbits/8, kt);
	BN_nnmod(kt, kt, N, ctx);

	/* step 2 */
	EC_SM2_POINT_mul(group, Pt, kt, G);		
	EC_SM2_POINT_affine2gem(group, Pt, Pz);
	EC_SM2_POINT_get_point(Pz, x, y, kt);
	

#ifdef TEST
{
		char *str;
		str = BN_bn2hex(x);
		printf("x: %s\n",str);
		nnl_free(str);

		str = BN_bn2hex(y);
		printf("y: %s\n",str);
		nnl_free(str);
}
#endif

	BN_hex2bn(&kt, "04");
	BN_lshift(kt, kt, g_uNumbits);
	BN_add(kt, kt, x);
	
	BN_lshift(kt, kt, g_uNumbits);
	BN_add(kt, kt, y);

	//bn_bn2bin(kt, 1 + 2 * g_uNumbits/8, pubkey);
	BN_bn2bin(kt, pubkey);
	*pubkey_len = 1 + 2 * g_uNumbits/8;

#ifdef TEST
{
		char *str;
		str = BN_bn2hex(kt);
		printf("04||x||y: %s\n",str);
		nnl_free(str);
}
#endif


	BN_free(N);
	BN_free(kt);
	BN_free(x);
	BN_free(y);
	EC_SM2_POINT_free(Pt);
	EC_SM2_POINT_free(Pz);
	BN_CTX_free(ctx);

	return 0;
}


/*
 * function:            calculate ecc public key from ecc private key. P=(xp, yp)=[d]G.
 * arguments:           prikey, the private key buffer point.
 *			prikey_len, the lenth of private key buffer, must bigger than SM2_PRIKEY_LEN.
 * 	                pubkey, the public key buffer point.
 *			pubkey_len, the lenth of public key buffer, must bigger than SM2_PUBKEY_LEN.
 * return value:        0 for success.  non-zero for error code.
 */
int sm2_is_key_match(const unsigned char *prikey, const unsigned int prikey_len, 
			const unsigned char *pubkey, const unsigned int pubkey_len)
{
	int ret;
	unsigned char pubkey_temp[65];
	unsigned int pubkey_templen = 65;

	if( prikey == NULL || pubkey == NULL)
	{
		return 1;
	}

	if( (prikey_len != g_uNumbits/8) || (pubkey_len != 1 + 2 * g_uNumbits/8) )
	{
		return 1;
	}

	ret = sm2_point_from_privatekey(prikey, prikey_len, pubkey_temp, &pubkey_templen);
	if( ret == 1 )
		return FALSE;

	if( memcmp(pubkey_temp, pubkey, pubkey_templen) != 0 )
		return FALSE;

	return TRUE;
}
