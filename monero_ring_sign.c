//
//  monero_ring_sign.c
//  testSM2
//
//  Created by zuoyongyong on 2019/12/17.
//  Copyright © 2019年 zuoyongyong. All rights reserved.
//
//refer to ring confidential transcations
#include "monero_ring_sign.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include "sm3.h"

#define MAX_RING_COUNT  10

typedef unsigned char BYTE;
typedef BYTE  PRIKEY[32];   // 32byte prikey
typedef BYTE  PUBKEY[64];   // 64byte pubkey
typedef PUBKEY PUBKEYLIST[MAX_RING_COUNT]; //64*64 byte matrix
typedef BYTE  PLAIN[32];    // 32byte plain


extern void print_hex(uint8_t *label, uint8_t *data, uint16_t data_len);

//generate signer keypair (ai, Ai)  user include (0,1,2, ..., n-1)
// generate other n-1 pubkey A0,A1,A2, ..Ai-1,..Ai+1..,An-1

unsigned int monero_rign_keygen(PRIKEY prikey, PUBKEY pubkey, PRIKEY prikeyImage)
{
    //1、 gen random 32byte x
    
    //2 、compute Pubkey P = xG
    
    //3、compute keyImage I = x*Hash(P)
    
    unsigned char*    pTemp_k = NULL;
    BIGNUM         *N;
    BIGNUM        *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *one;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz;
    unsigned char szpubkey[100] = {0};
    
    
    N = BN_new();
    kt = BN_new();
    x = BN_new();
    y = BN_new();
    one = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    pTemp_k = (unsigned char*)malloc(256);
    
    if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    /* start to generate d , d is random ,d is in [1, n-2] */
    /* d must be generated by SM3 random generator */
generate_d:
    
    if(rng(g_uNumbits, pTemp_k))
    {
        //PRINT_ERROR("rng return error\n");
        return 1;
    }
    BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
    BN_nnmod(kt, kt, N, ctx);
    
    if( BN_is_zero(kt) )
    {
        goto generate_d;
    }
    
    
    //bn_bn2bin(kt, g_uNumbits/8, prikey);
    if(prikey != NULL)
    {
        BN_bn2bin(kt, prikey);
    }
    
    
    //compute pubkey
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pz);
    EC_SM2_POINT_get_point(Pz, x, y, one);
    
    BN_lshift(x, x, g_uNumbits);
    BN_add(x, x, y);
    
    if(pubkey != NULL)
    {
        BN_bn2bin(x, pubkey);
    }
    
    //compute keyImage I = x*Hash(P)
    unsigned char hash[32] = {0};
    SM3(pubkey, 64, hash);
    BN_bin2bn(hash, sizeof(hash), x);
    
    BN_mul(x, kt, x, ctx);
    BN_nnmod(x, x, N, ctx);
    
    //ouput keyImage
    BN_bn2bin(x, prikeyImage);
    
    print_hex((uint8_t *)"keyimage is ", prikeyImage, 32);
    
    //free resource
    BN_free(N);
    BN_free(kt);
    BN_CTX_free(ctx);
    free(pTemp_k);
    
    return 0;
    
}

unsigned int monero_ring_sign(PLAIN plain, unsigned int signer, PRIKEY prikey, PRIKEY prikeyImage, PUBKEYLIST pubkeylist)
{
    // convert pubkeylist to P0,P1,P2 .., Pj, ...Pn-1 ; plain to m ; prikey to x; prikeyImage to I
    if(plain == NULL || prikey == NULL || prikeyImage == NULL || pubkeylist == NULL)
        return 1;
    
    // 1、generate random a, si( i=> {0,1,2..,j-1,j+1,...n-1} i!=j)
    unsigned char *pTemp = NULL;
    BIGNUM        *N;
    BIGNUM        *stArray[MAX_RING_COUNT];
    BIGNUM        *ctArray[MAX_RING_COUNT];
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *h;
    BIGNUM        *R;
    BN_CTX        *ctx;
    EC_SM2_POINT   *Pt[MAX_RING_COUNT],*Pz,*L;
    BIGNUM        *kt,*at;
    BIGNUM        *one;
    
    N = BN_new();
    x = BN_new();
    y = BN_new();
    h = BN_new();
    R = BN_new();
    ctx= BN_CTX_new();
    Pz = EC_SM2_POINT_new();
    L = EC_SM2_POINT_new();
    R = EC_SM2_POINT_new();
    one = BN_new();
    pTemp = (unsigned char*)malloc(256);
    
    if (ctx == NULL || pTemp == NULL )
    {
        return 1;
    }
    
    if(signer >= MAX_RING_COUNT)
    {
        return 1;
    }
    
    EC_SM2_GROUP_get_order(group, N);
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        stArray[i] = BN_new();
        ctArray[i] = BN_new();
        Pt[i] = EC_SM2_POINT_new();
        
    generate_d:
        
        memset(pTemp, 0, 256);
        if(rng(g_uNumbits, pTemp))
        {
            //PRINT_ERROR("rng return error\n");
            return 1;
        }
        if(i == signer)
        {
            at = BN_new();
            BN_bin2bn(pTemp, g_uNumbits/8, at);
            BN_nnmod(at, at, N, ctx);
            
            if( BN_is_zero(at) )
            {
                goto generate_d;
            }
        }
        else
        {
            BN_bin2bn(pTemp, g_uNumbits/8, stArray[i]);
            BN_nnmod(stArray[i], stArray[i], N, ctx);
            
            if( BN_is_zero(stArray[i]) )
            {
                goto generate_d;
            }
        }
        
        //convert pubkey to point
        BN_bin2bn(*(pubkeylist+i), 32, x);
        BN_bin2bn(*(pubkeylist+i) + 32, 32, y);
        BN_hex2bn(&one, "01");
        EC_SM2_POINT_set_point(Pt[i], x, y, one);
        
        
    }
    
    // 2、let Lj = aG Rj = a*Hash(Pj)  c(j+1) = Hash(Lj||m||Rj)
    int j = signer;
    EC_SM2_POINT_mul(group, L, at, G);
    EC_SM2_POINT_affine2gem(group, L, L);
    
    //compute Rj
    unsigned char szData[128] = {0};
    unsigned char hash[32] = {0};
    memcpy(szData, *(pubkeylist + signer), 32);
    memcpy(szData + 32,*(pubkeylist + signer) + 32, 32);
    SM3(szData, 64, hash);
    BN_bin2bn(hash, sizeof(hash), h);
    BN_mul(R, at, h, ctx);
    BN_nnmod(R, R, N, ctx);
    
    //compute cj+1
    
    
    /* 3、define L(j+1) = s(j+1)*G + c(j+1)*P(j+1)   R(j+1) = s(j+1)*Hash(pj+1) + c(j+1)*I
                  c(j+2) = Hash(Lj+1||m||Rj+1)
                   .....
                   .....
                 L(j-1) = s(j-1)*G + c(j-1)*P(j-1)  R(j-1) = s(j-1)*Hash(Pj-1) + c(j-1)*I
                 c(j) = Hash(Lj-1||m||Rj-1)
    
        according step 2 then a = sj + cj*x => sj = a - cj*x
    */
    
    //4、signature is sign {I,c0,s0,s1,...,sn-1}
    
    
    return 0;
}

unsigned int monero_ring_verify(PLAIN plain, PUBKEYLIST pubkeylist, unsigned char *signature)
{
    // convert pubkeylist to P0,P1,P2 .., Pj, ...Pn-1 ; plain to m ; signature to {I,c0,s0,s1,..,sn-1}
    
    // according Li = si*G + ci*Pi   Ri = si*Hash(Pi) + ci*I   ci+1 = Hash(Li||m||Ri)
    
    // compute cn then check cn == c0
    
    return 0;
}
