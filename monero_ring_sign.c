//
//  monero_ring_sign.c
//  testSM2
//
//  Created by zuoyongyong on 2019/12/17.
//  Copyright © 2019年 zuoyongyong. All rights reserved.
//
//refer to ring confidential transcations
#include "monero_ring_sign.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include "sm3.h"

#define MAX_RING_COUNT  10

typedef unsigned char BYTE;
typedef BYTE  PRIKEY[32];   // 32byte prikey
typedef BYTE  PUBKEY[64];   // 64byte pubkey
typedef PUBKEY PUBKEYLIST[MAX_RING_COUNT]; //64*64 byte matrix
typedef BYTE  PLAIN[32];    // 32byte plain


extern void print_hex(uint8_t *label, uint8_t *data, uint16_t data_len);

void printECPoint(EC_SM2_POINT *point)
{
    BIGNUM *kt = BN_new();
    BIGNUM *x = BN_new();
    BIGNUM *y = BN_new();
    
    EC_SM2_POINT_get_point(point, x, y, kt);
    
    char *str;
    str = BN_bn2hex(x);
    printf("x: %s ",str);
    free(str);
    
    str = BN_bn2hex(y);
    printf("y: %s\n",str);
    free(str);
    
    BN_free(kt);
    BN_free(x);
    BN_free(y);
}

//generate signer keypair (ai, Ai)  user include (0,1,2, ..., n-1)
// generate other n-1 pubkey A0,A1,A2, ..Ai-1,..Ai+1..,An-1

unsigned int monero_rign_keygen(PRIKEY prikey, PUBKEY pubkey, PRIKEY prikeyImage)
{
    //1、 gen random 32byte x
    
    //2 、compute Pubkey P = xG
    
    //3、compute keyImage I = x*Hash(P)
    
    unsigned char*    pTemp_k = NULL;
    BIGNUM         *N;
    BIGNUM        *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *one;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz;
    unsigned char szpubkey[100] = {0};
    
    
    N = BN_new();
    kt = BN_new();
    x = BN_new();
    y = BN_new();
    one = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    pTemp_k = (unsigned char*)malloc(256);
    
    if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    /* start to generate d , d is random ,d is in [1, n-2] */
    /* d must be generated by SM3 random generator */
generate_d:
    
    if(rng(g_uNumbits, pTemp_k))
    {
        //PRINT_ERROR("rng return error\n");
        return 1;
    }
    BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
    BN_nnmod(kt, kt, N, ctx);
    
    if( BN_is_zero(kt) )
    {
        goto generate_d;
    }
    
    
    //bn_bn2bin(kt, g_uNumbits/8, prikey);
    if(prikey != NULL)
    {
        BN_bn2bin(kt, prikey);
    }
    
    
    //compute pubkey
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pz);
    EC_SM2_POINT_get_point(Pz, x, y, one);
    
    BN_lshift(x, x, g_uNumbits);
    BN_add(x, x, y);
    
    if(pubkey != NULL)
    {
        BN_bn2bin(x, pubkey);
        //print_hex((uint8_t *)"pubkey is ", pubkey, 64);
    }
    
    //compute keyImage I = x*Hash(P)
    unsigned char hash[32] = {0};
    SM3(pubkey, 64, hash);
    BN_bin2bn(hash, sizeof(hash), x);
    
    BN_mul(x, kt, x, ctx);
    BN_nnmod(x, x, N, ctx);
    
    //ouput keyImage
    if(prikeyImage != NULL)
    {
        BN_bn2bin(x, prikeyImage);
        //print_hex((uint8_t *)"keyimage is ", prikeyImage, 32);
    }
    
    //free resource
    BN_free(N);
    BN_free(kt);
    BN_CTX_free(ctx);
    free(pTemp_k);
    
    return 0;
    
}

unsigned int monero_ring_sign(PLAIN plain, unsigned int signer, PRIKEY prikey, PRIKEY prikeyImage, PUBKEYLIST pubkeylist, unsigned char *signature, unsigned int *signlen)
{
    // convert pubkeylist to P0,P1,P2 .., Pj, ...Pn-1 ; plain to m ; prikey to x; prikeyImage to I
    if(plain == NULL || prikey == NULL || prikeyImage == NULL || pubkeylist == NULL)
        return 1;
    
    // 1、generate random a, si( i=> {0,1,2..,j-1,j+1,...n-1} i!=j)
    unsigned char *pTemp = NULL;
    BIGNUM        *N;
    BIGNUM        *stArray[MAX_RING_COUNT];
    BIGNUM        *ctArray[MAX_RING_COUNT];
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *h;
    BIGNUM        *R;
    BIGNUM        *I;
    BN_CTX        *ctx;
    EC_SM2_POINT   *Pt[MAX_RING_COUNT],*Pz,*L;
    BIGNUM        *kt,*at;
    BIGNUM        *one;
    unsigned  char szpubkey[64] = {0};
    
    N = BN_new();
    x = BN_new();
    y = BN_new();
    h = BN_new();
    R = BN_new();
    I = BN_new();
    kt = BN_new();
    ctx= BN_CTX_new();
    Pz = EC_SM2_POINT_new();
    L = EC_SM2_POINT_new();
    one = BN_new();
    pTemp = (unsigned char*)malloc(256);
    
    if (ctx == NULL || pTemp == NULL )
    {
        return 1;
    }
    
    if(signer >= MAX_RING_COUNT)
    {
        return 1;
    }
    
    EC_SM2_GROUP_get_order(group, N);
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        stArray[i] = BN_new();
        ctArray[i] = BN_new();
        Pt[i] = EC_SM2_POINT_new();
        
    generate_d:
        
        memset(pTemp, 0, 256);
        if(rng(g_uNumbits, pTemp))
        {
            //PRINT_ERROR("rng return error\n");
            return 1;
        }
        if(i == signer)
        {
            at = BN_new();
            BN_bin2bn(pTemp, g_uNumbits/8, at);
            BN_nnmod(at, at, N, ctx);
            
            if( BN_is_zero(at) )
            {
                goto generate_d;
            }
        }
        else
        {
            BN_bin2bn(pTemp, g_uNumbits/8, stArray[i]);
            BN_nnmod(stArray[i], stArray[i], N, ctx);
            
            if( BN_is_zero(stArray[i]) )
            {
                goto generate_d;
            }
        }
        
        //convert pubkey to point
        
        EC_SM2_POINT_bin_to_point(*(pubkeylist + i), 64, Pt[i]);
        //printECPoint(Pt[i]);
        
    }
    
    // 2、let Lj = aG Rj = a*Hash(Pj)  c(j+1) = Hash(Lj||m||Rj)
    int j = (signer+1)%MAX_RING_COUNT;
    EC_SM2_POINT_mul(group, L, at, G);
    EC_SM2_POINT_affine2gem(group, L, L);
    
    //compute Rj
    unsigned char szData[512] = {0};
    unsigned char hash[32] = {0};
    SM3(*(pubkeylist+signer), 64, hash);
    BN_bin2bn(hash, sizeof(hash), h);
    BN_mul(R, at, h, ctx);
    BN_nnmod(R, R, N, ctx);
    
    //compute cj+1 = Hash(Lj||m||Rj)
    memset(szData, 0, sizeof(szData));
    EC_SM2_POINT_point_to_bin(L, szData);
    memcpy(szData+64, plain, 64);
    BN_bn2bin(R, szData+128);
    memset(hash, 0, sizeof(hash));
    SM3(szData, 160, hash);
    BN_bin2bn(hash, sizeof(hash), ctArray[j]);
    //print_hex((uint8_t *)"ct is ", hash, sizeof(hash));
    
    //convert keyimage to I
    BN_bin2bn(prikeyImage, 32, I);
    
    /* 3、define L(j+1) = s(j+1)*G + c(j+1)*P(j+1)   R(j+1) = s(j+1)*Hash(pj+1) + c(j+1)*I
                  c(j+2) = Hash(Lj+1||m||Rj+1)
                   .....
                   .....
                 L(j-1) = s(j-1)*G + c(j-1)*P(j-1)  R(j-1) = s(j-1)*Hash(Pj-1) + c(j-1)*I
                 c(j) = Hash(Lj-1||m||Rj-1)
    
        according step 2 then a = sj + cj*x => sj = a - cj*x
    */
    
    while(j != signer)
    {
        memset(szData, 0, sizeof(szData));
        memset(hash, 0, sizeof(hash));
        
        //compute L(j) = s(j)*G + c(j)*P(j)
        EC_SM2_POINT_mul(group, L, stArray[j], G);
        EC_SM2_POINT_mul(group, Pz, ctArray[j], Pt[j]);
        EC_SM2_POINT_add(group, L, L, Pz);
        EC_SM2_POINT_affine2gem(group, L, L);
        //printECPoint(L);
        
        //compute R(j) = s(j)*Hash(pj) + c(j)*I
        EC_SM2_POINT_point_to_bin(Pt[j], szpubkey);
        SM3(szpubkey, 64, hash);
        BN_bin2bn(hash, 32, h);
        BN_mul(R, stArray[j], h, ctx);
        BN_mul(kt, ctArray[j], I, ctx);
        BN_add(R, R, kt);
        BN_nnmod(R, R, N, ctx);
        
        
        
        //compute c(j+1) = Hash(Lj||m||Rj)
        EC_SM2_POINT_point_to_bin(L, szData);
        memcpy(szData + 64, plain, 64);
        BN_bn2bin(R, szData + 128);
        SM3(szData, 160, hash);
        BN_bin2bn(hash, sizeof(hash), ctArray[(j+1)%MAX_RING_COUNT]);
        //print_hex((uint8_t *)"ct is ", hash, sizeof(hash));
        
        j++;
        j = j%MAX_RING_COUNT;
    }
    
    // sj =  a - cj*x
    BN_bin2bn(prikey, 32, x);
    BN_mul(kt, ctArray[signer], x, ctx);
    BN_sub(stArray[signer], at, kt);
    BN_nnmod(stArray[signer], stArray[signer], N, ctx);
    
    //4、signature is sign {I,c0,s0,s1,...,sn-1}
    memcpy(signature, prikeyImage, 32);
    *signlen = 32;
    BN_bn2bin(ctArray[0], signature+32);
    *signlen += 32;
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        BN_bn2bin(stArray[i], signature + *signlen);
        *signlen += 32;
        EC_SM2_POINT_free(Pt[i]);
    }
    
    //free resource
    
    BN_free(N);
    BN_free(x);
    BN_free(y);
    BN_free(h);
    BN_free(R);
    BN_free(I);
    BN_free(one);
    BN_free(kt);
    BN_CTX_free(ctx);
    EC_SM2_POINT_free(Pz);
    EC_SM2_POINT_free(L);
    free(pTemp);

    
    return 0;
}

unsigned int monero_ring_verify(PLAIN plain, PUBKEYLIST pubkeylist, unsigned char *signature, unsigned int signlen)
{
    if(plain == NULL || pubkeylist == NULL || signature == NULL)
    {
        return 1;
    }
    // convert pubkeylist to P0,P1,P2 .., Pj, ...Pn-1 ; plain to m ; signature to {I,c0,s0,s1,..,sn-1}
    BN_CTX        *ctx;
    BIGNUM        *stArray[MAX_RING_COUNT];
    BIGNUM        *N;
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *h;
    BIGNUM        *R;
    BIGNUM        *I;
    BIGNUM        *ct;
    BIGNUM        *c0;
    EC_SM2_POINT   *Pt[MAX_RING_COUNT],*Pz,*L;
    unsigned char szData[512] = {0};
    unsigned char hash[32] = {0};
    
    N = BN_new();
    x = BN_new();
    y = BN_new();
    h = BN_new();
    R = BN_new();
    I = BN_new();
    ct = BN_new();
    c0 = BN_new();
    ctx= BN_CTX_new();
    Pz = EC_SM2_POINT_new();
    L = EC_SM2_POINT_new();
    
    EC_SM2_GROUP_get_order(group, N);
    
    BN_bin2bn(signature, 32, I);
    BN_bin2bn(signature + 32, 32, c0);
    BN_copy(ct, c0);
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        Pt[i] = EC_SM2_POINT_new();
        EC_SM2_POINT_bin_to_point(*(pubkeylist+i), 64, Pt[i]);
        //printECPoint(Pt[i]);
        
        stArray[i] = BN_new();
        BN_bin2bn(signature+64+i*32, 32, stArray[i]);
    }
    
    // according Li = si*G + ci*Pi   Ri = si*Hash(Pi) + ci*I   ci+1 = Hash(Li||m||Ri)
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        //Li = si*G + ci*Pi
        EC_SM2_POINT_mul(group, L, stArray[i], G);
        EC_SM2_POINT_mul(group, Pz, ct, Pt[i]);
        EC_SM2_POINT_add(group, L, L, Pz);
        EC_SM2_POINT_affine2gem(group, L, L);
        
        //printECPoint(L);
        
        //Ri = si*Hash(Pi) + ci*I
        memset(hash, 0, sizeof(hash));
        SM3(pubkeylist[i], 64, hash);
        BN_bin2bn(hash, sizeof(hash), h);

        BN_mul(R, stArray[i], h, ctx);
        BN_mul(x, ct, I, ctx);
        BN_add(R, R, x);
        BN_nnmod(R, R, N, ctx);
        
        //ci+1 = Hash(Li||m||Ri)
        memset(szData, 0, sizeof(szData));
        EC_SM2_POINT_point_to_bin(L, szData);
        memcpy(szData + 64, plain, 64);
        BN_bn2bin(R, szData + 128);
        memset(hash, 0, sizeof(hash));
        SM3(szData, 160, hash);
        
        //print_hex((uint8_t *)"ct  is ", hash, sizeof(hash));
        BN_bin2bn(hash, sizeof(hash), ct);
        BN_nnmod(ct, ct, N, ctx);
        
    }
    
     // compute cn then check cn == c0
    if(BN_cmp(ct, c0) == 0)
    {
        printf(" ring verify success ...\n");
    }
    else
    {
        printf(" ring verify failed ...\n");
    }
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        BN_free(stArray[i]);
        EC_SM2_POINT_free(Pt[i]);
    }
    
    BN_free(N);
    BN_free(x);
    BN_free(y);
    BN_free(h);
    BN_free(R);
    BN_free(I);
    BN_free(c0);
    BN_free(ct);
    BN_CTX_free(ctx);
    EC_SM2_POINT_free(Pz);
    EC_SM2_POINT_free(L);

    
    return 0;
}

void test_monero_ring_signature()
{
    PLAIN plain = "the sample text to be sign";
    PUBKEYLIST  pubkeylist;
    PRIKEY  prikey;
    PRIKEY  prikeyImage;
    unsigned int ret = 0;
    unsigned int signer = 3;
    unsigned char signature[(MAX_RING_COUNT+2)*32] = {0};
    unsigned int signlen = sizeof(signature);
    
    for(int i = 0; i < MAX_RING_COUNT; i++)
    {
        if(i == signer)
        {
            ret = monero_rign_keygen(prikey, pubkeylist[i], prikeyImage);
        }
        else
        {
            ret = monero_rign_keygen(NULL, pubkeylist[i], NULL);
        }
        if(ret != 0)
        {
            printf("monero ring key gen failed ...\n");
            return ;
        }
    }
    
    printf("monero ring key gen success .. \n");
    
    ret = monero_ring_sign(plain, signer, prikey, prikeyImage, pubkeylist, signature, &signlen);
    if(ret != 0)
    {
        printf("monero ring sign faild .. \n");
        return ;
    }
    
    printf("monero ring sign success ...\n");
    
    ret = monero_ring_verify(plain, pubkeylist, signature, signlen);
    if(ret != 0)
    {
        printf("monero ring verify failed ...\n");
        return ;
    }
    
    printf("monero ring verify success ... \n");
    

    return ;

}
