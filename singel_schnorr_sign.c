//
//  schnorr_sign.c
//  testSM2
//
//  Created by zuoyongyong on 2019/11/15.
//  Copyright © 2019年 zuoyongyong. All rights reserved.
//

#include "singel_schnorr_sign.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include "sm3.h"
#include "sm4.h"
#include "kdf.h"
#include "jvcrypto.h"


int schnorr_genkeypair(unsigned char *prikey, unsigned int *prikeylen, unsigned char *pubkey, unsigned int *pubkeylen)
{
    unsigned char*    pTemp_k = NULL;
    BIGNUM         *N;
    BIGNUM        *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz;
    
    if( prikey == NULL  || *prikeylen < g_uNumbits/8 )
    {
        return 1;
    }
    
    N = BN_new();
    kt = BN_new();
    x = BN_new();
    y = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    pTemp_k = (unsigned char*)malloc(256);
    
    if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    /* start to generate d , d is random ,d is in [1, n-2] */
    /* d must be generated by SM3 random generator */
generate_d:
    
    if(rng(g_uNumbits, pTemp_k))
    {
        //PRINT_ERROR("rng return error\n");
        return 1;
    }
    BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
    BN_nnmod(kt, kt, N, ctx);
    
    if( BN_is_zero(kt) )
    {
        goto generate_d;
    }
    
    
    //bn_bn2bin(kt, g_uNumbits/8, prikey);
    BN_bn2bin(kt, prikey);
    *prikeylen = g_uNumbits/8;
    
    
    //compute pubkey
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pz);
    EC_SM2_POINT_get_point(Pz, x, y, kt);
    
    BN_hex2bn(&kt, "04");
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, x);
    
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, y);
    
    //bn_bn2bin(kt, 1 + 2 * g_uNumbits/8, pubkey);
    BN_bn2bin(kt, pubkey);
    *pubkeylen = 1 + 2 * g_uNumbits/8;
    
    
    //free resource
    
    BN_free(N);
    BN_free(kt);
    BN_CTX_free(ctx);
    free(pTemp_k);

    
    return 0;
}

int schnorr_sign(unsigned char *plain, unsigned int plainlen, unsigned char *prikey, unsigned int prikeylen, unsigned char *sign, unsigned int *signlen)
{
    
    //1、choose random r, compute R = r*G
    
    
    //2、compute Rx = R(x)Hashdata : H(m,Rx)=>h
    
    
    //3、compute S = r + h*k  (k is prikey)
    
    
    //4、signature is (Rx, S)
    
    
    return 0;
}

int schnorr_verify(unsigned char *plain, unsigned int plainlen, unsigned char *sign, unsigned int signlen, unsigned char *pubkey, unsigned int pubkeylen)
{
    
    //convert sign to (Rx, S)  plain is m  pubkey is P
    
    //1、compute h = H(m,Rx)
    
    //2、 compute (x,y) = S*G - h*P
    
    //3、compare x is equal to Rx
    
    return 0;
}

