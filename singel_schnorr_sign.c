//
//  schnorr_sign.c
//  testSM2
//
//  Created by zuoyongyong on 2019/11/15.
//  Copyright © 2019年 zuoyongyong. All rights reserved.
//

#include "singel_schnorr_sign.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bn.h"
#include "bnEx.h"
#include "ec_operations.h"
#include "bn_operations.h"
#include "rand.h"
#include "sm2.h"
#include "sm3.h"
#include "sm4.h"
#include "kdf.h"
#include "jvcrypto.h"


int schnorr_genkeypair(unsigned char *prikey, unsigned int *prikeylen, unsigned char *pubkey, unsigned int *pubkeylen)
{
    unsigned char*    pTemp_k = NULL;
    BIGNUM         *N;
    BIGNUM        *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BN_CTX         *ctx;
    EC_SM2_POINT *Pt,*Pz;
    
    if( prikey == NULL  || *prikeylen < g_uNumbits/8 )
    {
        return 1;
    }
    
    N = BN_new();
    kt = BN_new();
    x = BN_new();
    y = BN_new();
    ctx= BN_CTX_new();
    Pt = EC_SM2_POINT_new();
    Pz = EC_SM2_POINT_new();
    pTemp_k = (unsigned char*)malloc(256);
    
    if ( kt == NULL || ctx == NULL || pTemp_k == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    /* start to generate d , d is random ,d is in [1, n-2] */
    /* d must be generated by SM3 random generator */
generate_d:
    
    if(rng(g_uNumbits, pTemp_k))
    {
        //PRINT_ERROR("rng return error\n");
        return 1;
    }
    BN_bin2bn(pTemp_k, g_uNumbits/8, kt);
    BN_nnmod(kt, kt, N, ctx);
    
    if( BN_is_zero(kt) )
    {
        goto generate_d;
    }
    
    
    //bn_bn2bin(kt, g_uNumbits/8, prikey);
    BN_bn2bin(kt, prikey);
    *prikeylen = g_uNumbits/8;
    
    
    //compute pubkey
    EC_SM2_POINT_mul(group, Pt, kt, G);
    EC_SM2_POINT_affine2gem(group, Pt, Pz);
    EC_SM2_POINT_get_point(Pz, x, y, kt);
    
    BN_hex2bn(&kt, "04");
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, x);
    
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, y);
    
    //bn_bn2bin(kt, 1 + 2 * g_uNumbits/8, pubkey);
    BN_bn2bin(kt, pubkey);
    *pubkeylen = 1 + 2 * g_uNumbits/8;
    
    
    //free resource
    
    BN_free(N);
    BN_free(kt);
    BN_CTX_free(ctx);
    free(pTemp_k);

    
    return 0;
}

int schnorr_sign(unsigned char *plain, unsigned int plainlen, unsigned char *prikey, unsigned int prikeylen, unsigned char *sign, unsigned int *signlen)
{
    unsigned char*    pTemp_r = NULL;
    BIGNUM         *N;
    BIGNUM        *kr, *kt;
    BIGNUM        *x;
    BIGNUM        *y;
    BIGNUM        *k;
    BIGNUM        *h;
    BN_CTX         *ctx;
    EC_SM2_POINT *R,*P;
    unsigned char hash[32] = {0};
    
    if(plain == NULL || prikey == NULL || signlen == NULL)
    {
        return 1;
    }
    
    N = BN_new();
    kr = BN_new();
    kt = BN_new();
    k = BN_new();
    x = BN_new();
    y = BN_new();
    h = BN_new();
    ctx= BN_CTX_new();
    R = EC_SM2_POINT_new();
    P = EC_SM2_POINT_new();
    pTemp_r = (unsigned char*)malloc(256);
    
    if ( kr== NULL || ctx == NULL || pTemp_r == NULL )
    {
        return 1;
    }
    EC_SM2_GROUP_get_order(group, N);
    
    //1、choose random r, compute R = r*G
    
generate_d:
    
    if(rng(g_uNumbits, pTemp_r))
    {
        return 1;
    }
    BN_bin2bn(pTemp_r, g_uNumbits/8, kr);
    BN_nnmod(kr, kr, N, ctx);
    
    if( BN_is_zero(kr) )
    {
        goto generate_d;
    }
    
    //get R = r*G
    EC_SM2_POINT_mul(group, R, kr, G);
    EC_SM2_POINT_affine2gem(group, R, R);
    
    
    //2、compute Rx = R(x)Hashdata : H(Rx||P||m)=>h
    unsigned char *pData = malloc(plainlen + 128);
    unsigned int datalen = 0;
    if(pData == NULL)
    {
        return 1;
    }
    // Rx
    EC_SM2_POINT_get_point(R, x, y, kt);
    BN_bn2bin(x, pData);
    datalen = g_uNumbits/8;
    
    //P
    BN_bin2bn(prikey, prikeylen, k);
    EC_SM2_POINT_mul(group, P, k, G);
    EC_SM2_POINT_affine2gem(group, P, P);
    EC_SM2_POINT_get_point(P, x, y, kt);
    BN_lshift(kt, x, g_uNumbits);
    BN_lshift(kt, kt, g_uNumbits);
    BN_add(kt, kt, y);
    BN_bn2bin(kt, pData+datalen);
    datalen += g_uNumbits/4;
    
    //plain text
    memcpy(pData + datalen, plain, plainlen);
    datalen += plainlen;
    
    //compute sm3 hash
    SM3(pData, datalen, hash);
    
    //convert to bignum h
    BN_bin2bn(hash, 32, h);
    
    
    //3、compute S = r + h*k  (k is prikey)
    BN_mul(kt, k, h, ctx);
    BN_add(kt, kt, kr);
    BN_nnmod(kt, kt, N, ctx);

    
    //4、signature is (Rx, S)
    memcpy(sign, pData, g_uNumbits/8);
    BN_bn2bin(kt, sign+g_uNumbits/8);
    
    *signlen = g_uNumbits/4;
    
    free(pTemp_r);
    free(pData);
    
    BN_free(N);
    BN_free(kt);
    BN_free(kr);
    BN_free(k);
    BN_free(h);
    BN_free(x);
    BN_free(y);
    EC_SM2_POINT_free(P);
    EC_SM2_POINT_free(R);
    BN_free(kt);
    BN_CTX_free(ctx);
    
    return 0;
}

int schnorr_verify(unsigned char *plain, unsigned int plainlen, unsigned char *sign, unsigned int signlen, unsigned char *pubkey, unsigned int pubkeylen)
{
    
    //convert sign to (Rx, S)  plain is m  pubkey is P
    
    //1、compute h = H(Rx||P||m)
    
    //2、 compute (x,y) = S*G - h*P
    
    //3、compare x is equal to Rx
    
    return 0;
}

